import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @author 25526693 | CJ TELFER
 */

/**
 * This class represents a finite automaton, which consists of a set of
 * states,a set of transitions between those states, and a set of accept
 * state
 * -> It allows for the addition of states and transitions, as well
 * as finding all possible words that can be generated by the automaton
 */
public class Automaton {

    /**
     * Nested class for states
     * -> each state has an ID and a map of transitions
     * -> keys are input symbols and the values are sets of IDs for the next states
     */
    private class State {
        private int id;
        private Map<Integer, Set<Integer>> transitions;

        /**
         * Constructs a new State object with the given ID and an empty map of
         * transitions
         *
         * @param id -> ID of this state
         */
        State(int id) {
            this.id = id;
            transitions = new HashMap<>();
        }

        /**
         * Returns the ID of this state
         *
         * @return -> ID of this state
         */
        public int getId() {
            return this.id;
        }

        /**
         * Adds a transition to this state's map of transitions
         * -> If the input symbol is not already in the map, a new
         * entry is created with an empty set of IDs for the next states
         * -> ID for the next state is added to the set of IDs for the input symbol.
         *
         * @param input     -> the input symbol for the transition
         * @param nextState -> the ID of the next state
         */
        public void addTransition(int input, int nextState) {
            if (!transitions.containsKey(input)) {
                transitions.put(input, new HashSet<Integer>());
            }
            transitions.get(input).add(nextState);
        }

        /**
         * Returns the set of IDs for the next states for the given input symbol in this
         * state's map of transitions
         * -> If the input symbol is not in the map, an empty set is returned
         *
         * @param input -> the input symbol for the transition
         * @return -> the set of IDs for the next states for the given input symbol
         */
        public Set<Integer> getTransitions(int input) {
            return transitions.getOrDefault(input, Collections.emptySet());
        }
    }

    private List<State> states;
    private List<Integer> acceptStates;
    private int count = 0;

    /**
     * Constructs a new Automaton object with an initial state of ID 0 (start state)
     */
    public Automaton() {
        this.states = new ArrayList<>();
        this.acceptStates = new ArrayList<>();
        this.states.add(new State(0));
    }

    /**
     * Adds a new state to this automaton with the given ID
     * -> If the ID already exists in the list of states
     *
     * @param id -> ID of the new state
     */
    public void addState(int id) {
        while (states.size() < id + 1) {
            states.add(new State(states.size()));
        }
    }

    /**
     * Fetches and returns the number of states in the automaton
     * 
     * @return int states -> The number of states
     */
    public int getNumStates() {
        return states.size();
    }

    /**
     * Adds a new transition to this automaton from the start state to the next
     * state with the given input symbol
     *
     * @param startState -> ID of the start state for the transition
     * @param toState    -> ID of the next state for the transition
     * @param input      -> input symbol for the transition
     */
    public void addTransition(int startState, int toState, int input) {
        states.get(startState).addTransition(input, toState);
    }

    /**
     * Adds a new accept state to the automaton, given its ID
     *
     * @param id -> ID of state to add as an accept state
     */
    public void addAcceptState(int id) {
        acceptStates.add(id);
    }

    /**
     * Fetches and returns the list of accept states in the automaton
     * 
     * @return The list of accept states as Strings
     */
    public List<Integer> getAccStates() {
        return acceptStates;
    }

    /**
     * Returns a list of all possible words that can be generated by the automaton
     * -> performs a depth-first search of the automaton to find all possible words,
     * given the wordlen specified. If wordLen <= 0, no multi-resolution is used
     * 
     * @param wordLen -> The value of the wordlen (resolution)
     * @return -> List of all possible words generated ny the automaton
     */
    public List<String> findWords(int wordLen) {
        List<String> words = new ArrayList<>();
        if (wordLen > 0) {
            dfs3(0, "", words, wordLen);
        } else {
            dfs(0, "", words);
        }
        return words;
    }

    /**
     * Performs a depth-first search of the automaton starting from the given state,
     * constructing each possible word
     * -> If the given state is an accept state, adds the current word to the list
     * of words
     * -> Recursively searches each transition from the current state, adding each
     * input to the current word as it goes.
     *
     * @param state -> current state to search from
     * @param word  -> current word constructed from the search path so far
     * @param words -> list of words generated by the automaton
     */
    private void dfs(int state, String word, List<String> words) {
        if (acceptStates.contains(state)) {
            words.add(word);
        }

        for (int input : getAlphabet()) {
            for (int nextState : states.get(state).getTransitions(input)) {
                dfs(nextState, word + input, words);
            }
        }

    }

    /**
     * Performs a depth-first search of the automaton starting from the given state,
     * constructing each possible word
     * -> If the given state is an accept state, adds the current word to the list
     * of words
     * -> Recursively searches each transition from the current state, adding each
     * input to the current word as it goes.
     * -> Accounts for cycles with an additional parameter checking for wordLen
     * 
     * @param state   -> current state to search from
     * @param word    -> current word constructed from the search path so far
     * @param words   -> list of words generated by the automaton
     * @param wordLen -> the multi-resolution wordLen allowed, break cycles after it
     *                is reached
     */
    private void dfs3(int state, String word, List<String> words, int wordLen) {
        if (word.length() == wordLen) {
            if (acceptStates.contains(state)) {
                words.add(word);
            }
            return;
        }

        Map<Integer, Set<Integer>> transitions = states.get(state).transitions;
        if (transitions != null) {
            for (int input : getAlphabet()) {
                for (int nextState : states.get(state).getTransitions(input)) {
                    dfs3(nextState, word + input, words, wordLen);
                }
            }
        }

    }

    /**
     * Returns the set of all possible inputs that the automaton can accept
     * {0, 1, 2, 3}
     *
     * @return -> set of alphabet {0, 1, 2, 3}
     */
    private Set<Integer> getAlphabet() {
        Set<Integer> alphabet = new HashSet<>();
        for (State state : states) {
            for (int input : state.transitions.keySet()) {
                alphabet.add(input);
            }
        }
        return alphabet;
    }

    /**
     * Fetches the list of all transitions in the current automaton
     * -> Returns list in the form <origin state> <destination state> <symbol>
     * -> Adds the number of states and a list of all accept states to the top of
     * the list
     * 
     * @param mode -> The value corresponding to the mode of multi-resolution
     *             compression
     * @return -> The list of all accept states and transitions between states
     */
    public List<String> getTransitions(int mode) {
        List<String> str = new ArrayList<>();
        String newStr = acceptStates.get(0) + "";
        str.add(states.size() + "");
        for (int i = 1; i < acceptStates.size(); i++) {
            newStr = newStr + " " + acceptStates.get(i);
        }
        str.add(newStr);

        // checkerboard -> multi-res
        if (mode == 2) {
            str.add("0 0 0");
            str.add("0 0 1");
            str.add("0 0 2");
            str.add("0 0 3");
        }

        for (State state : states) {
            int id = state.getId();
            for (int input : state.transitions.keySet()) {
                for (int nextState : state.getTransitions(input)) {
                    newStr = id + " " + nextState + " " + (char) input;
                    str.add(newStr);
                }
            }
        }

        return str;
    }

}
